<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: study | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-08-14T22:11:20+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[postgresql indexes]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/06/01/postgresql-indexes/"/>
    <updated>2014-06-01T10:18:27+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/06/01/postgresql-indexes</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<p>Indexes will speed up your read(SELECT) and write(INSERT, UPDATE, DELETE) operation on a table, but they should by removed when a query seldom or never used. Create a bit table&rsquo;s index will spend lot of time. By default, PostgreSQL allows reads (SELECT statements) to occur on the table in parallel with index creation, but writes (INSERT, UPDATE, DELETE) are blocked until the index build is finished. In production environments this is often unacceptable. It is possible to allow writes to occur in parallel with index creation, but there are several caveats to be aware of — for more information see <a href="http://www.postgresql.org/docs/9.3/static/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY">Building Indexes Concurrently</a>.</p>

<h1>Index Types</h1>

<p>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST and GIN. By default, the CREATE INDEX command creates B-tree indexes, which fit the most common situations.</p>

<h1>Multicolumn index</h1>

<p>Currently, only the B-tree, GiST and GIN index types support multicolumn indexes. Up to 32 columns can be specified. (This limit can be altered when building PostgreSQL; see the file pg_config_manual.h.)</p>

<p>if your frequently query is like this: <code>SELECT name FROM test2 WHERE major = constant AND minor = constant;</code>, your need create an index on table test2 with <code>major</code>, <code>minor</code> columns: <code>CREATE INDEX test2_mm_idx ON test2 (major, minor);</code></p>

<p>The order is important in multicolumn index:</p>

<blockquote><p>A multicolumn B-tree index can be used with query conditions that involve any subset of the index&rsquo;s columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on (a, b, c) and a query condition WHERE a = 5 AND b >= 42 AND c &lt; 77, the index would have to be scanned from the first entry with a = 5 and b = 42 up through the last entry with a = 5. Index entries with c >= 77 would be skipped, but they&rsquo;d still have to be scanned through. This index could in principle be used for queries that have constraints on b and/or c with no constraint on a — but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</p></blockquote>

<h1>Order By</h1>

<p>By default, B-tree indexes store their entries in ascending order with nulls last.</p>

<h1>Combining Multiple Indexes</h1>

<p>little difficult just trade off to decide which indexes to provide. Sometimes multicolumn indexes are best, but sometimes it&rsquo;s better to create separate indexes and rely on the index-combination feature.</p>

<h1>Index on Expressions</h1>

<p>This kind of index, not a specific column, it&rsquo;s an expression: <code>CREATE INDEX people_names ON people ((first_name || ' ' || last_name));</code></p>

<h1>Partial Index</h1>

<p><code>CREATE INDEX idx_xxx ON table(name) WHERE NOT deleted</code> this index only enables to rows which deleted is <code>TRUE</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[log2n和log3n]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/05/30/log2n-log3n/"/>
    <updated>2014-05-30T20:45:44+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/05/30/log2n-log3n</id>
    <content type="html"><![CDATA[<p>merge sort的时间复杂度，log2n，曾经在算法书上看到过，相应的，merge sort也可以三分，复杂度变成log3n，好像还不错，但差多少呢？</p>

<p>log3n=log2n/log2(3)，也就是只差了1/log2(3)对于看起来还更大。一般算法复杂度是log2n表示就是这个原因，loga(n)和log2n差不了太多，都是常数级别的差距，而且在复杂度分析的时候都会忽略常数，所以就简记为log2n复杂度了：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rarp]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/08/25/rarp/"/>
    <updated>2013-08-25T12:01:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/08/25/rarp</id>
    <content type="html"><![CDATA[<h2>Packet Format</h2>

<p>RARP packet is identical to ARP packet, differences: RARP &lsquo;type&rsquo; field is 0x8035 for request and reply and &lsquo;op&rsquo; field is 3 for RARP request and 4 for RARP reply.</p>

<p>RARP&rsquo;s reply is unicast.</p>

<p>The implementation of RARP server is complex&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[conceptual-models]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/08/19/conceptual-models/"/>
    <updated>2013-08-19T22:12:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/08/19/conceptual-models</id>
    <content type="html"><![CDATA[<h2>Conceptual Models</h2>

<p>Designing software so that its structure reflects that of the problem.</p>

<p>Analysis is not only listing requirments, but also looking behind the surface requirments to come up with a mental model of what is going in the problem.</p>

<p>Conceptual model is a human artifact.</p>

<p>Developers use conceptual models to represent a model of the real world in order to understanding the read part of problems easily.</p>

<p>There is no right or wrong model, merely one that is more useful for the job at hand.</p>

<p>The example, snooker simulation, if your choose a Einsteinian model would be flexible enought to low speed or high speed situation, but the complexity is totally different you know, so the flexibility and many others aspects need a trade-off.</p>

<p>When building a model in a programming language, maybe Python, you may get lost in this language or building this model using some features belong to Python, so this model is a Python-model, and it is hard to be implemented in other languages such as Java, PHP, etc. To avoid these problems, you need a third-party analysis techniques.</p>

<p>Only domain experts could build right model, because of their domain knowledge.</p>

<p>Conceptual model is closely to software interfaces rather than software implementations. One of the important things about OO is that it separates interface from implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[arp]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/08/18/arp/"/>
    <updated>2013-08-18T20:38:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/08/18/arp</id>
    <content type="html"><![CDATA[<pre><code>32 bits Internet address
|                   /|
|ARP                 |RARP
|/                   |
48 bits Ethernet address
</code></pre>

<h1>Gratuitous ARP</h1>

<ol>
<li>send its own IP to verify whether someone has used this.</li>
<li>update old MAC address in ARP cache</li>
</ol>

]]></content>
  </entry>
  
</feed>
