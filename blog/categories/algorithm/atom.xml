<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-08-22T23:30:52+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[逆序对的求解]]></title>
    <link href="http://www.youth2009.org/www/blog/2012/05/07/solve-inversion-by-using-merge/"/>
    <updated>2012-05-07T17:08:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2012/05/07/solve-inversion-by-using-merge</id>
    <content type="html"><![CDATA[<p>今天看到算法导论上关于求解一个序列的逆序对的问题，以前自己在这个地方写着解答方法，不过今天怎么看都不懂了，从网上找了找，大都说得很模糊，不过自己突然有种领悟了的感觉，找了个简单的例子，实验了一下，自己的结论是正确的：）</p>

<p>例子是（2，3，8，6，1）这个序列，找出所有的5个逆序对。最好的方法是nlogn复杂度的利用归并排序的副产品——merge部分统计，统计比较左右列表时，左侧大于右侧时“左侧”列表中剩余数目。</p>

<p>归并的划分应该是这样的，（2，3，8）为左侧，（6，1）为右侧，继续划分为（2，3）和8，右边是6和1。下面就开始合并了，（2，3）和8这边还是（2，3，8），右侧出现一个逆序对，在合并6，1的时候因为作为“左侧”的6要大于1，所以这里有1个逆序对，这里的1就是此时“左侧”序列中的元素个数。</p>

<p>在往下走，要合并（2，3，8）和（1，6），马上就出现了2>1这样的情况，此时会出现（2，1）、（3，1）、（8，1）这几个逆序对，后面还会出现（8，6）这个逆序对，一共就这么5个。</p>

<p>因为原始序列是（2，3，8，6，1），我们需要用到这个原始序列的顺序来判断顺序排在前面的值却大于后面的，这样的机会在每次merge的时候是非常合适的。</p>

<p>这是修改后输出逆序对的归并排序算法，有点可惜哈，这么长的排序算法只让副产品在台前显露了一把！</p>

<p>&#8220;`python</p>

<h1>! /usr/bin/env python</h1>

<h1>coding: utf-8</h1>

<p>def merge(arraylist, first, middle, last):
   temp = []
   i = first
   j = middle + 1
   while i &lt;= middle and j &lt;= last:</p>

<pre><code>   if arraylist[i] &lt;= arraylist[j]:
       temp.append(arraylist[i])
       i += 1
   else:
       for x in arraylist[i:middle + 1]:
           print "(%d,%d)" % (x, arraylist[j])
       temp.append(arraylist[j])
       j += 1
</code></pre>

<p>   while i &lt;= middle:</p>

<pre><code>   temp.append(arraylist[i])
   i += 1
</code></pre>

<p>   while j &lt;= last:</p>

<pre><code>   temp.append(arraylist[j])
   j += 1
</code></pre>

<p>   for i in range(0, last &ndash; first + 1):</p>

<pre><code>   arraylist[first + i] = temp[i]
</code></pre>

<p>def merge_sort(arraylist, first, last):
   if first &lt; last:</p>

<pre><code>   middle = (first + last) / 2
   merge_sort(arraylist, first, middle)
   merge_sort(arraylist, middle + 1, last)
   merge(arraylist, first, middle, last)
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
lst = [2,3,8,6,1]
merge_sort(lst, 0, len(lst) &ndash; 1)
&#8220;`</p>

<p>运行结果：</p>

<p><code>bash
(6,1)
(2,1)
(3,1)
(8,1)
(8,6)
</code></p>

<p>（我的代码缩进似乎出了点问题，本身这段归并排序也是从网上找来的，所以混合了不少tab和whitespace，弄了好久都是error indent，最后我无奈用whitespace来做缩进，好歹调试通过了！）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[9个数运算结果为110]]></title>
    <link href="http://www.youth2009.org/www/blog/2012/04/08/9-numbers-calculate-110/"/>
    <updated>2012-04-08T14:20:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2012/04/08/9-numbers-calculate-110</id>
    <content type="html"><![CDATA[<p>昨天参加了一个小型编程比赛，有个题目是这样的，有1～9这九个数字，按照顺序排列着，你可以在他们之间加入加号、减号或者什么都不加，组成的算式经过运算后结果为110的输出出来。</p>

<p>看着好简单的题目，当时比赛时候就是一下子没做出来，现在做好了，贴出来，如果有需要可以拿去用哈，代码风格不算好，因为是比赛嘛，又不是商业项目，先快速得到结果再说！</p>

<p>&#8220;`java
import java.util.ArrayList;</p>

<p>public class unittest
{
   public static void main(String[] argStrings)
   {</p>

<pre><code>   long start = System.currentTimeMillis();
   ArrayList&lt;String&gt; allopts = new ArrayList&lt;String&gt;();
   int a,b,c,d,e,f,g,h;
   for(a = 0;a &lt; 3;a++)
       for(b = 0;b &lt; 3;b++)
           for(c = 0;c &lt; 3;c++)
               for(d = 0;d &lt; 3;d++)
                   for(e = 0;e &lt; 3;e++)
                       for(f = 0;f &lt; 3;f++)
                           for(g = 0;g &lt; 3;g++)
                               for(h = 0;h &lt; 3;h++) {
                                   allopts.add(""+a+b+c+d+e+f+g+h);
                               }

   for (String string : allopts)
   {
       String base = "1x2x3x4x5x6x7x8x9";
       for (int i = 0; i &lt; string.length(); i++)
       {
           String tmp = getOpt(Integer.parseInt(""+string.charAt(i)));
           base = base.replaceFirst("x", tmp);
       }
       int x = getResult(base, string.replaceAll("2", "").replaceAll("0", "+").replaceAll("1", "-"));//2-&gt;null
       if (x == 110)
       {
           System.out.println(base);
       }
   }
   System.out.println("All Run Time: " + (System.currentTimeMillis() - start) + "ms");
</code></pre>

<p>   }</p>

<p>   public static String getOpt(int opt) {</p>

<pre><code>   String retString = "";
   switch (opt)
   {
       case 0:
           retString = "+";
           break;
       case 1:
           retString = "-";
           break;
       case 2:
           retString = "";
           break;
       default:
           break;
   }

   return retString;
</code></pre>

<p>   }</p>

<p>   public static int getResult(String calculatString, String optString)
   {</p>

<pre><code>   ArrayList&lt;Integer&gt; allNum = new ArrayList&lt;Integer&gt;();
   ArrayList&lt;String&gt; allOpt = new ArrayList&lt;String&gt;();
   for (String string : calculatString.split("[+-]"))
   {
       allNum.add(Integer.parseInt(string));
   }
   for (int i = 0; i &lt; optString.length(); i++)
   {
       allOpt.add(optString.charAt(i) + "");
   }
   int result = allNum.get(0);
   for (int i = 1; i &lt; allNum.size(); i++)
   {
       char x = (i - 1) == allOpt.size()?'+':allOpt.get(i - 1).charAt(0);
       int nextNum = i == allNum.size()?0:allNum.get(i);
       result = getValue(result, nextNum, x);
   }

   return result;
</code></pre>

<p>   }</p>

<p>   public static int getValue(Integer num1, Integer num2, char opt)
   {</p>

<pre><code>   int ret = 0;
   switch (opt)
   {
       case '+':
           ret = num1 + num2;
           break;
       case '-':
           ret = num1 - num2;
           break;
       default:
           break;
   }

   return ret;
</code></pre>

<p>   }
}
&#8220;`</p>

<p>结果是这样的：</p>

<p><code>bash
1+2+34+5+67-8+9
1+234-56-78+9
1-2+3+45-6+78-9
12+3+45+67-8-9
12+34+56+7-8+9
12-3+4-5+6+7+89
123+4+5+67-89
123+4-5-6-7-8+9
123-4+5-6-7+8-9
123-4-5+6+7-8-9
All Run Time: 496ms
</code></p>

<p>最后我算了算运行时间，应该这就是很慢的了，幸好只有加减和空，要不然会更麻烦的……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[约瑟夫问题算法]]></title>
    <link href="http://www.youth2009.org/www/blog/2011/04/23/algo-circle-count-quit/"/>
    <updated>2011-04-23T09:54:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2011/04/23/algo-circle-count-quit</id>
    <content type="html"><![CDATA[<p>昨晚还在忙碌网站，一个同学发来短信问了这样一个算法问题：一些人手拉手围成一个圈，从一个人开始报数，数到3的人退出，然后下一个人再开始报数，依然是数到3者退出，问最后剩下2个人是哪两个？</p>

<p>这题目看起来不算难，但这要是不靠一个语言的特性来解决，还是有些麻烦的。我说的语言特性就是一个bt数组方法，比如说移除元素啊这样的方法，用纯粹的C语言来写最好了。不过我那位同学是在雪VB.net不知道那里有没有语言特性。我手头上正在写PHP网页，就干脆用PHP写一个出来试试吧：）  </p>

<p>&#8220;`php
$circle = array();
$out = 0;
$count = 0;
$n = 0;</p>

<p>for($i = 0;$i &lt; $num;$i++) {
$circle[$i] = $i;
}
while(1) {
$count %= $num;
if($circle[$count] !== -1) {
if(($n % $diff) == ($diff &ndash; 1)) {
$circle[$count] = -1;
$out++;
if($out === $num &ndash; $sur)
break;
}
$n++;
}
$count++;
}
&#8220;`</p>

<p>这就是主要代码了，还算是简单吧？去Google了一下，看到有些人的解法都用了好麻烦的链表来抽象，用链表确实更符合客观事实，不过那样写起来，是不是给别人看的呢？！</p>

<p>算法的负责度显然是线性的，感觉还可以吧。</p>
]]></content>
  </entry>
  
</feed>
