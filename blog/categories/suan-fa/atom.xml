<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Trade Off]]></title>
  <link href="http://www.youth2009.org/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/"/>
  <updated>2013-08-03T23:32:09+08:00</updated>
  <id>http://www.youth2009.org/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[约瑟夫问题算法]]></title>
    <link href="http://www.youth2009.org/blog/2011/04/23/algo-circle-count-quit/"/>
    <updated>2011-04-23T09:54:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2011/04/23/algo-circle-count-quit</id>
    <content type="html"><![CDATA[<p>昨晚还在忙碌网站，一个同学发来短信问了这样一个算法问题：一些人手拉手围成一个圈，从一个人开始报数，数到3的人退出，然后下一个人再开始报数，依然是数到3者退出，问最后剩下2个人是哪两个？ 这题目看起来不算难，但这要是不靠一个语言的特性来解决，还是有些麻烦的。我说的语言特性就是一个bt数组方法，比如说移除元素啊这样的方法，用纯粹的C语言来写最好了。不过我那位同学是在雪VB.net不知道那里有没有语言特性。我手头上正在写PHP网页，就干脆用PHP写一个出来试试吧：）  </p>

<pre class="prettyprint linenums bush:php" lang="php">$circle = array();
$out = 0;
$count = 0;
$n = 0;

for($i = 0;$i &lt; $num;$i++) {
$circle[$i] = $i;
}
while(1) {
$count %= $num;
if($circle[$count] !== -1) {
if(($n % $diff) == ($diff - 1)) {
$circle[$count] = -1;
$out++;
if($out === $num - $sur)
break;
}
$n++;
}
$count++;
}</pre>


<p>这就是主要代码了，还算是简单吧？去Google了一下，看到有些人的解法都用了好麻烦的链表来抽象，用链表确实更符合客观事实，不过那样写起来，是不是给别人看的呢？！</p>

<p>算法的负责度显然是线性的，感觉还可以吧。</p>

<p>这里有篇论文，我暂时还看不大懂，对于这个问题写得很详细。（下载：<a href="http://www.youth2009.org/works/josephus.pdf">josephus.pdf</a>）</p>
]]></content>
  </entry>
  
</feed>
