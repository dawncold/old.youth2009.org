<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-08-22T23:30:52+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[basestring-and-str-in-python2x]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/08/08/basestring-and-str-in-python2x/"/>
    <updated>2013-08-08T21:39:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/08/08/basestring-and-str-in-python2x</id>
    <content type="html"><![CDATA[<p>今天在代码中发现原本过滤str的一个func被写成了过滤basestring，于是查了下basestring和str的区别：(在3.0之前)</p>

<p>&#8220;`</p>

<pre><code>       object
         |
         |
     basestring
        / \
       /   \
     str  unicode
</code></pre>

<p>&#8220;`</p>

<p>3.0之前python中有plain string和unicode string，前者是ascii中的那些字符，后者就是所有字符了，因为historical legacy。。。python出现的时候还木有unicode，所以很多python的lib是需要慢慢转换的，当然到了3.0就会不复存在了，全是unicode。</p>

<p>这样的话就清楚了，str代表了那些ascii字符，unicode就是全部的字符，他们都继承自basestring。basestring是从python2.3开始引入的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[crontab a python script]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/07/21/crontab-a-python-script/"/>
    <updated>2013-07-21T22:28:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/07/21/crontab-a-python-script</id>
    <content type="html"><![CDATA[<p>今天用python写了个<a href="https://github.com/dawncold/stuff/blob/master/ping_test.py">小程序</a>检测网络是否通断，如果断了就弹出一个Notification，当然是Mac上的，并且弹出一个terminal，带着执行ping www.baidu.com。</p>

<p>一开始用Lingon加入到启动项中并且打算2分钟执行一次，几经折腾终于失败，弃之。打算用crontab弄。</p>

<p>好歹算是可用了吧，注意的是：script的开头写/usr/bin/python，crontab中写PATH没用，得写PYTHONPATH才管用，而且我还写了MAILTO（现在不知道管什么用）。由于在script中用了popen，可能这个需要依赖一些环境或者是tty（这是从stackoverflow上看来的，具体可以搜popen crontab），现在想来launchd是不是也因为如此没能成功启动呢？（总提示255退出代码）</p>

<p>crontab:</p>

<p><code>bash
MAILTO="dawncold@me.com"
PATH=/Users/dawncold/.rvm/gems/ruby-1.9.3-p286/bin:/Users/dawncold/.rvm/gems/ruby-1.9.3-p286@global/bin:/Users/dawncold/.rvm/rubies/ruby-1.9.3-p286/bin:/Users/dawncold/.rvm/bin:/Library/Frameworks/Python.framework/Versions/2.7/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/MacGPG2/bin
PYTHONPATH=/usr/bin
* * * * * /Users/dawncold/ping_test.py &gt; /Users/dawncold/pt
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[generator-in-python]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/03/13/generator-in-python/"/>
    <updated>2013-03-13T21:52:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/03/13/generator-in-python</id>
    <content type="html"><![CDATA[<p>今天在代码中遇到一个next方法（python代码），以前从没用过这个，于是简单了解了一下。</p>

<p>next就是iterator了，可以通过iterator来找东西，找到就停下了，如果给了默认值，没找到的话就用默认值。</p>

<p>generator这个东西是很有意思的，比如：</p>

<p><code>python
def other_firstn(n):
 num, nums = 0, []
 while num &lt; n:
   nums.append(num)
   num += 1
 return nums
</code>
可以产生一个list，里面是按顺序的数字，有n个，结果类似于range(n)的返回值。</p>

<p>还有一个版本的firstn：</p>

<p><code>python
def firstn(n):
 num = 0
 while num &lt; n:
   yield num
   num += 1
</code>
这个看起来就很帅了，代码也简洁了很多，yield是十分神奇的表达式，产生了一个num，这里不太好想，不能按照正常的function来思考这个执行顺序了。</p>

<p>总之，如果产生100个数字，你可以一下子弄出100个来，或者你知道规则的话，你就弄出第一个来，然后用的时候按照规则，从第一个一直走下去，也产生了100个。最大的不同就是性能，后者必然速度更快了，前提是数量要足够多！写了一个简单的性能对比，主要是时间上的，内存上的不容易监控。</p>

<p>&#8220;`</p>

<h1>/usr/bin/python</h1>

<h1>! &ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>import time</p>

<p>def firstn(n):
 num = 0
 while num &lt; n:
   yield num
   num += 1</p>

<p>def other_firstn(n):
 num, nums = 0, []
 while num &lt; n:
   nums.append(num)
   num += 1
 return nums</p>

<p>def timer(func_wrap, func, <em>args, **kwards):
 s = time.time()
 r = func_wrap(func(</em>args, **kwards))
 e = time.time()
 print &lsquo;return: %s   use %f ms[s: %s, e: %s]&rsquo; % (r, (e &ndash; s), s, e)</p>

<p>def main():
 timer(sum, firstn, 1000000)
 timer(sum, other_firstn, 1000000)</p>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
 main()
<code>
输出结果是：大约会慢1倍
</code>bash
dawncold [21:49:11] ~=>$ python 1.py
return: 499999500000   use 0.137414 ms[s: 1363182552.38, e: 1363182552.52]
return: 499999500000   use 0.290716 ms[s: 1363182552.52, e: 1363182552.81]
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pytz的6分钟时差]]></title>
    <link href="http://www.youth2009.org/www/blog/2012/10/20/6-minutes-offset-in-pytz/"/>
    <updated>2012-10-20T16:13:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2012/10/20/6-minutes-offset-in-pytz</id>
    <content type="html"><![CDATA[<p>项目中有使用pytz这个第三方库来处理datetiem相关的东西。不过最近测试的时候发现，创建了一个时间点后，最终得到的时间点和预想的时间点有6分钟的误差，从网上搜到的资料是这样解决的：详情看<a href="http://hi.baidu.com/limodou/item/72da32384b25c7ff97f88df1">http://hi.baidu.com/limodou/item/72da32384b25c7ff97f88df1</a></p>

<p>创建datetime的时候，特别是带timezone，需要localize一下，否则在使用pytz的时候就会出现这6分钟的差异。代码中首先创建了datetime，然后localize后再replace了timezone为pytz的，最终还astimezone为pytz.utc。我们是使用utc的，你的代码也许不需要：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中dict格式化]]></title>
    <link href="http://www.youth2009.org/www/blog/2012/10/04/dict-formatting-in-python/"/>
    <updated>2012-10-04T17:54:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2012/10/04/dict-formatting-in-python</id>
    <content type="html"><![CDATA[<p>最近在工作中遇到过写SQL的问题，参数是直接传递进去的，比如这样：</p>

<p><code>python
db().execute('SELECT * FROM xxx WHERE id = %(id)s', id=get_id())
</code></p>

<p>今天细看Google提供的Python课程发现一个叫DictFormatting的部分，里面就有类似这样的语法，现在才明白。以前用过Python的格式化输出，其实这个dict的格式化和字符串的类似，就是在字符串格式化的基础之上加入了dict的key，%s是表示这里有字符串，而%(xxx)s是表示字符串，而且是以xxx为key的字符串，这个value就是从字典中给出。一半会在这样一个字符串后加“% dictname”表示值从dictname这个字典中给出，这不就是和字符串格式化一样么。</p>
]]></content>
  </entry>
  
</feed>
