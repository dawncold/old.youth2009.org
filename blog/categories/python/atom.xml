<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trade Off]]></title>
  <link href="http://www.youth2009.org/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/"/>
  <updated>2013-08-25T15:22:28+08:00</updated>
  <id>http://www.youth2009.org/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[generator-in-python]]></title>
    <link href="http://www.youth2009.org/blog/2013/03/13/generator-in-python/"/>
    <updated>2013-03-13T21:52:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2013/03/13/generator-in-python</id>
    <content type="html"><![CDATA[<p>今天在代码中遇到一个next方法（python代码），以前从没用过这个，于是简单了解了一下。</p>

<p>next就是iterator了，可以通过iterator来找东西，找到就停下了，如果给了默认值，没找到的话就用默认值。</p>

<p>generator这个东西是很有意思的，比如：</p>

<p><code>python
def other_firstn(n):
 num, nums = 0, []
 while num &lt; n:
   nums.append(num)
   num += 1
 return nums
</code>
可以产生一个list，里面是按顺序的数字，有n个，结果类似于range(n)的返回值。</p>

<p>还有一个版本的firstn：</p>

<p><code>python
def firstn(n):
 num = 0
 while num &lt; n:
   yield num
   num += 1
</code>
这个看起来就很帅了，代码也简洁了很多，yield是十分神奇的表达式，产生了一个num，这里不太好想，不能按照正常的function来思考这个执行顺序了。</p>

<p>总之，如果产生100个数字，你可以一下子弄出100个来，或者你知道规则的话，你就弄出第一个来，然后用的时候按照规则，从第一个一直走下去，也产生了100个。最大的不同就是性能，后者必然速度更快了，前提是数量要足够多！写了一个简单的性能对比，主要是时间上的，内存上的不容易监控。</p>

<p>```</p>

<h1>/usr/bin/python</h1>

<h1>! &ndash;<em>&ndash; coding: utf-8 &ndash;</em>&ndash;</h1>

<p>import time</p>

<p>def firstn(n):
 num = 0
 while num &lt; n:
   yield num
   num += 1</p>

<p>def other_firstn(n):
 num, nums = 0, []
 while num &lt; n:
   nums.append(num)
   num += 1
 return nums</p>

<p>def timer(func_wrap, func, <em>args, **kwards):
 s = time.time()
 r = func_wrap(func(</em>args, **kwards))
 e = time.time()
 print &lsquo;return: %s   use %f ms[s: %s, e: %s]&rsquo; % (r, (e &ndash; s), s, e)</p>

<p>def main():
 timer(sum, firstn, 1000000)
 timer(sum, other_firstn, 1000000)</p>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
 main()
<code>
输出结果是：大约会慢1倍
</code>bash
dawncold [21:49:11] ~=>$ python 1.py
return: 499999500000   use 0.137414 ms[s: 1363182552.38, e: 1363182552.52]
return: 499999500000   use 0.290716 ms[s: 1363182552.52, e: 1363182552.81]
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[统计词频方法]]></title>
    <link href="http://www.youth2009.org/blog/2012/10/04/print-words-count/"/>
    <updated>2012-10-04T18:32:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2012/10/04/print-words-count</id>
    <content type="html"><![CDATA[<p>记得上次参加美味书签电面的时候被问到如何统计一个语料库中的词频，当时有点傻，刚刚在复习Python的dict也遇到了这样的问题，一下子认识到，原来可以做得这么简单。虽然不知道有没有更爽的办法，但我觉得我这种方法也算是能用了，能够保证一定效率的情况下，可理解性也很强。</p>

<p>读取一行行的word，存入dict，word作为key，value就是出现次数了，这样都是linear的事件复杂度，如果在字典就把value加1，要是不在就把value设为1即可。dict的查找复杂度很低，是hash查找。</p>

<p>唉，会不会就是这样我才被拒掉了呢？！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中dict格式化]]></title>
    <link href="http://www.youth2009.org/blog/2012/10/04/dict-formatting-in-python/"/>
    <updated>2012-10-04T17:54:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2012/10/04/dict-formatting-in-python</id>
    <content type="html"><![CDATA[<p>最近在工作中遇到过写SQL的问题，参数是直接传递进去的，比如这样：</p>

<p><code>python
db().execute('SELECT * FROM xxx WHERE id = %(id)s', id=get_id())
</code></p>

<p>今天细看Google提供的Python课程发现一个叫DictFormatting的部分，里面就有类似这样的语法，现在才明白。以前用过Python的格式化输出，其实这个dict的格式化和字符串的类似，就是在字符串格式化的基础之上加入了dict的key，%s是表示这里有字符串，而%(xxx)s是表示字符串，而且是以xxx为key的字符串，这个value就是从字典中给出。一半会在这样一个字符串后加“% dictname”表示值从dictname这个字典中给出，这不就是和字符串格式化一样么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中的sort方法]]></title>
    <link href="http://www.youth2009.org/blog/2012/10/04/sort-method-in-python/"/>
    <updated>2012-10-04T14:58:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2012/10/04/sort-method-in-python</id>
    <content type="html"><![CDATA[<p>打算从今天开始自习再学学Python的基础，选了Google提供的Python课程，学到list部分，有个练习题目要求针对一组tuples排序，根据tuples的最后一个元素排序，有个hint，可以用key=function这种方法，于是搜索了一番，在Python的wiki中找到这个key方法的描述：</p>

<p>从Python2.4以后list.sort()和sorted()方法都提供了一个key可选参数，传入一个function用来决定排序需要的key。这个key就是所排序元素的权值，最终就是根据权值来排序了。你也可以自己写一个方法，就是那种用def来定义的方法，不过要求接受一个参数，返回一个值，接受的参数就是这个集合（list、dict、tuple）中的某个元素。我是这样写的，it works：</p>

<p><code>python
def sort_last(tuples):
 # +++your code here+++
 tuples.sort(key = lambda t: t[-1])
 return tuples
</code></p>

<p>根据tuple中最后一个排序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于又回到了开发一线]]></title>
    <link href="http://www.youth2009.org/blog/2012/08/09/return-to-develop/"/>
    <updated>2012-08-09T10:45:00+08:00</updated>
    <id>http://www.youth2009.org/blog/2012/08/09/return-to-develop</id>
    <content type="html"><![CDATA[<p>前两天把系统从Lion升级到了MountainLion，这一升级不要紧，很多开发环境都需要重装，比如Java又得重新下载，Python的类库又消失了，XCode过期了。。。</p>

<p>听说了一个好消息，从XCode4.4.1开始，以后的XCode都会采用增量更新，但这次除外，1.56Gb的XCode，在这种破网速中用了两天才搞定。</p>

<p>Python的一个类库MySQL-python需要gcc-4.2才能编译，于是还需要下载CommandLineTool，又是155Mb。。。（但装好XCode后可以从XCode.app中找到llvm-gcc-4.2，我是用这个编译的，也能用）。</p>

<p>还有几个小的python类库，装好后就能继续用了。这次系统升级后MySQL竟然没有问题，值得表扬一下！</p>
]]></content>
  </entry>
  
</feed>
