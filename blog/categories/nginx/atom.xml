<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: nginx | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/nginx/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-09-05T23:40:55+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[without-nginx-upload-module]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/07/01/without-nginx-upload-module/"/>
    <updated>2013-07-01T23:28:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/07/01/without-nginx-upload-module</id>
    <content type="html"><![CDATA[<p>前些天把nginx-upload-module这个依赖去掉了，用了nginx builtin的方法，感觉更好了，其实深层原因是这个module的作者不玩了。。。只有感受到了这种切肤之痛才有变革的动力！！！</p>

<p>主要内容记录在了这里：<a href="http://www.youth2009.org/blog/2013/06/25/nginx-upload-file-without-backend/">http://www.youth2009.org/blog/2013/06/25/nginx-upload-file-without-backend/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx-upload-file-without-backend]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/06/25/nginx-upload-file-without-backend/"/>
    <updated>2013-06-25T23:09:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/06/25/nginx-upload-file-without-backend</id>
    <content type="html"><![CDATA[<p>以前用了nginx-upload-module，不过这个module的作者不打算继续更新了，导致nginx版本高于1.3.9就无法使用这个module来处理上传文件。本着不引入更多依赖并且使用一个比较成熟方法的前提，只有client_body_in_file_only，这是nginx buildin方法。</p>

<p>原本用upload-module的时候在location / 中有个if，如果发现有multipart就会处理一下，再pass回去。处理完后会多出两个参数，比如image.name和image.path，其中image是file input的name。然后back-end就直接那path和name来处理文件了，临时文件会放在一个固定的地方。</p>

<p>由于client_body_in_file_only只能放在server、http、location中，得专门建立一个location而不能放在if中。</p>

<p>&#8220;`
location ^~ /upload/ {
  client_body_temp_path      /tmp/;
  client_body_in_file_only   on;
  client_body_buffer_size    128K;
  client_max_body_size       1000M;</p>

<p>  proxy_pass_request_headers on;
  proxy_set_header           X-FILE $request_body_file;
  proxy_set_body             off;
  proxy_redirect             off;
  proxy_pass                 <a href="http://backend/">http://backend/</a>
}
&#8220;`
这样以upload开头的就会做这样处理，上传的文件path会放在header中，至于name该怎么办，我是把name的值作为query string拼在了form的action中，在上传开始前得到文件名，然后拼上去。</p>

<p>需要注意的是，client_body_in_file_only不支持RFC2388，也就是说multipart不管用，你可以考虑用ajax上传插件来做上传，注意插件里的multipart设为false。上传插件推荐JQuery-File-Upload。</p>

<p>依赖，越少越好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx下的location配置]]></title>
    <link href="http://www.youth2009.org/www/blog/2011/07/10/nginx-location-config/"/>
    <updated>2011-07-10T20:15:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2011/07/10/nginx-location-config</id>
    <content type="html"><![CDATA[<p>原来的location只是处理了“/”的情况，结果访问一个目录，即使此目录下有index.html也不会成功显示，于是改成了这样：</p>

<p>&#8220;`
location ~.*.(php|php5)?$
{</p>

<pre><code>处理php
</code></pre>

<p>}
&#8220;`</p>

<p>这样之后，发现直接访问目录或者域名的时候不能正常显示了，必须跟上index.php这样的才可以。</p>

<p>最终改成这样，解决了问题：</p>

<p>&#8220;`
location / {</p>

<pre><code>           root html;
           index index.html index.php;
</code></pre>

<p>}
location ~.*.(php|php5)?$ {
处理php
}
&#8220;`</p>
]]></content>
  </entry>
  
</feed>
