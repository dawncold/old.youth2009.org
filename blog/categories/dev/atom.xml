<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-06-01T20:50:58+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python-main-py]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/05/30/python-main-py/"/>
    <updated>2014-05-30T21:05:20+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/05/30/python-main-py</id>
    <content type="html"><![CDATA[<p>python的<code>__main__.py</code>文件，通常，一个package下有一个<code>__init__.py</code>文件标识这是package，同样可以有一个<code>__main__.py</code>文件，有了后你就可以这样运行一个脚本：<code>python script_dir</code>或者把这个dir打包成zip，可以使用<code>python zipball.zip</code>来执行，python会执行<code>__main__.py</code>中的语句。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[disable-keyboard-on-ubuntu]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/05/30/disable-keyboard-on-ubuntu/"/>
    <updated>2014-05-30T20:54:45+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/05/30/disable-keyboard-on-ubuntu</id>
    <content type="html"><![CDATA[<p>有时候不接外置显示器的时候，喜欢把键盘压在笔记本键盘上方使用，但如果不禁用内置键盘的话就会有误操作的风险，所以这样做，利用ubuntu中的xinput</p>

<p>查看设备使用<code>xinput list</code></p>

<p>```bash
⎡ Virtual core pointer                      id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad                id=11   [slave  pointer  (2)]
⎜   ↳ Logitech USB-PS/2 Optical Mouse           id=12   [slave  pointer  (2)]
⎜   ↳ Logitech Unifying Device. Wireless PID:4004   id=13   [slave  pointer  (2)]
⎣ Virtual core keyboard                     id=3    [master keyboard (2)]</p>

<pre><code>↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
↳ Power Button                              id=6    [slave  keyboard (3)]
↳ Video Bus                                 id=7    [slave  keyboard (3)]
↳ Sleep Button                              id=8    [slave  keyboard (3)]
↳ Acer CrystalEye webcam                    id=9    [slave  keyboard (3)]
↳ AT Translated Set 2 keyboard              id=10   [slave  keyboard (3)]
</code></pre>

<p><code>``
找到内置键盘，我这里是那个叫"AT Translated Set 2 keyboard"的，id是10，禁用使用：</code>xinput float 10`</p>

<p>如果再启用使用<code>xinput reattach 10 3</code>，3标识这个设备的master的id，从list的结果很容易看到从属关系。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[md5 digest]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/05/30/md5-digest/"/>
    <updated>2014-05-30T20:29:58+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/05/30/md5-digest</id>
    <content type="html"><![CDATA[<p>对于一个字符串做md5，例如："<order></order>123456"做完md5后，比较常见的结果是：<code>2e08539049ac0f6b5b4377ec20145c06</code>，即十六进制的表示形式，长度一般是32位，有人也用16位的表示，就是把32位的字符串前后各去掉8位后的结果，但不多见。还有就是用md5的digest值，这是一个16字节的字符串，不容易看，但可以转换成ascii后观察，比如上面的digest就是：<code>[46, 8, 83, 144, 73, 172, 15, 107, 91, 67, 119, 236, 32, 20, 92, 6]</code>， 如果你还看不清的话，可以考虑把这些ascii转成十六进制再看看：<code>['2e', '08', '53', '90', '49', 'ac', '0f', '6b', '5b', '43', '77', 'ec', '20', '14', '5c', '06']</code>，是不是很熟悉了，对就是一开始那个32位长的字符串。</p>

<p>在对某通的接口开发中遇到对发送数据校验，文档中说的是对数据进行md5再做base64，通常就是把那个32位长的字符串做base64，但怎么也对不上，后来再研究发现其实是用digest的结果做base64，太坑人了是吧，文档这个东西，能写详细就写详细点，没坏处。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dive-into-tornado]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/03/27/dive-into-tornado/"/>
    <updated>2014-03-27T21:22:58+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/03/27/dive-into-tornado</id>
    <content type="html"><![CDATA[<p>早就有这样的计划，要深入了解自己在用的工具，veil算一个，tornado算一个，flask算一个……当然还有好多，总得一个个看一番，好在这些库都写得足够简单，不至于一下子看不懂，而且借助pycharm这样优秀的工具，一步步跟踪代码也给深入理解框架极大的帮助，所以，开始吧。（也好久都没更新过技术博客的内容了）</p>

<p>终于可以再让Mac发挥发挥余热了，pycharm用的社区版，估计对于学习够用了。tornado升级到了稳定的3.2版，也是目前的最新版，先慢慢研读官方的文档，再慢慢看完api。</p>

<p>在写hello，world例子的时候，处理GET我直接就下意识返回了想要的字符串，没想到运行起来是500 error，仔细一看原来官方的例子中处理GET是要调用<code>self.write('xxx')</code>，然后我就看了下self.write做了什么，self是我定义的class，但这个class继承自tornado.web.RequestHandler, 于是看tornado.web.RequestHandler的write做什么，write的参数叫chunk，并不是简单的叫str之类的东西，也就是说不限于str，有可能是些别的东西，比如注释中说如果你write了一个dict，tornado会转换成JSON，并且把Content-Type给你设置好，现在的veil也支持了这个优秀特性。还提到了list不会被转换成JSON格式，因为一个漏洞（坑），具体看<a href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/">这里</a>，简单讲，就是用script的src指向一个网站需要登陆后才能访问的地址，因为你如果登陆过的话，cookie信息会随之发送到这个地址，此时如果你去了一个邪恶的网站，他里面有些脚本，引用刚刚提到的你需要登陆的网址，你浏览器会把你的一些信息带上，请求这个地址，这个地址会返回一些你的个人资料，比如是用JSON的array回给你，但邪恶网站把javascript array的constructor改写了，你拿到JSON的array会被自动转成js array，这样邪恶网站会收集到你的信息，然后再发送回自己一个接受数据的接口就可以了。避免方法就是：返回JSON的时候用对象方式；这种关键信息用POST提交，script标签只会发送GET请求；现代高级浏览器都不会有问题，大可放心。转换成了byte string（就是str）放入chunk_buffer，一起写到output。</p>

<p>我们的handler很简单，实现了get方法，然后write了一个字符串，但后来呢？或许应该从另一条路看起——从url被映射到handler看起。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[return-value-in-jquery-json-datatype]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/23/return-value-in-jquery-json-datatype/"/>
    <updated>2014-01-23T18:57:21+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/23/return-value-in-jquery-json-datatype</id>
    <content type="html"><![CDATA[<p>向api server发送请求做一件事的时候，比如修改密码，server做完后没有返回值，response code是200。这在原来的时候没问题，“原来”是指ajax的dataType未指定的时候，jQuery会自己猜测用什么，但这次指定了server的response是json，所以，即便是看到200 code也未能调用OnSuccess，空返回值对于json是不合法的，于是返回一个什么东西就好，当然要先to_json再返回。</p>
]]></content>
  </entry>
  
</feed>
