<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-01-16T22:27:40+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[nginx-and-dependences]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/16/nginx-and-dependences/"/>
    <updated>2014-01-16T18:46:33+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/16/nginx-and-dependences</id>
    <content type="html"><![CDATA[<p><code>bash
wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.34.tar.gz
wget http://www.openssl.org/source/openssl-1.0.1f.tar.gz
wget http://nginx.org/download/nginx-1.5.8.tar.gz
</code></p>

<p>default install pcre and openssl</p>

<p>```
nginx configure
+gzip</p>

<p>Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + md5: using system crypto library
  + sha1: using system crypto library
  + using system zlib library
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lxml-and-dependences]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/16/lxml-and-dependences/"/>
    <updated>2014-01-16T18:31:09+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/16/lxml-and-dependences</id>
    <content type="html"><![CDATA[<p><code>bash
sudo apt-get install libxml2-dev
sudo apt-get install libxslt1-dev
sudo apt-get install python-dev  （if Python.h: No file or dir..）
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[useful-shell-command]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/12/07/useful-shell-command/"/>
    <updated>2013-12-07T22:28:53+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/12/07/useful-shell-command</id>
    <content type="html"><![CDATA[<p>找到size为0的文件，并删除：<code>find -type f -size 0 | xargs rm</code></p>

<p>替换Linux的换行成windows的：<code>ls | xargs perl -i -pe 's/\n/\r\n/g'</code></p>

<p>批量改名哦（把<em>.md改为</em>.markdown）：</p>

<p><code>bash
for i in `ls *.md`;do mv $i `echo $i | sed 's/.md/.markdown/'`;done
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx-upload-file-without-backend]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/06/25/nginx-upload-file-without-backend/"/>
    <updated>2013-06-25T23:09:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/06/25/nginx-upload-file-without-backend</id>
    <content type="html"><![CDATA[<p>以前用了nginx-upload-module，不过这个module的作者不打算继续更新了，导致nginx版本高于1.3.9就无法使用这个module来处理上传文件。本着不引入更多依赖并且使用一个比较成熟方法的前提，只有client_body_in_file_only，这是nginx buildin方法。</p>

<p>原本用upload-module的时候在location / 中有个if，如果发现有multipart就会处理一下，再pass回去。处理完后会多出两个参数，比如image.name和image.path，其中image是file input的name。然后back-end就直接那path和name来处理文件了，临时文件会放在一个固定的地方。</p>

<p>由于client_body_in_file_only只能放在server、http、location中，得专门建立一个location而不能放在if中。</p>

<p>```
location ^~ /upload/ {
  client_body_temp_path      /tmp/;
  client_body_in_file_only   on;
  client_body_buffer_size    128K;
  client_max_body_size       1000M;</p>

<p>  proxy_pass_request_headers on;
  proxy_set_header           X-FILE $request_body_file;
  proxy_set_body             off;
  proxy_redirect             off;
  proxy_pass                 <a href="http://backend/">http://backend/</a>
}
```
这样以upload开头的就会做这样处理，上传的文件path会放在header中，至于name该怎么办，我是把name的值作为query string拼在了form的action中，在上传开始前得到文件名，然后拼上去。</p>

<p>需要注意的是，client_body_in_file_only不支持RFC2388，也就是说multipart不管用，你可以考虑用ajax上传插件来做上传，注意插件里的multipart设为false。上传插件推荐JQuery-File-Upload。</p>

<p>依赖，越少越好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dog-pile-effect]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/05/18/dog-pile-effect/"/>
    <updated>2013-05-18T22:48:00+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/05/18/dog-pile-effect</id>
    <content type="html"><![CDATA[<p>如果你的网站该去解决dog pile effect了，那应该有不小的PV了。今天看暴走漫画的架构设计，那是应对1000W PV的一个设计，当然架构这东西每家都不一样，可能这个就他们自己用着适合。里面提到了dog pile effect，这个的意思是：在多request去cache中拿数据的时候，如果发现自己拿的数据是过期了的，那么就要去db中拿新的来。这么看好像没问题，但有前提的——request很多，真的很多，而且确实用cache了（反正我不相信request很多的时候某些数据你不用cache，那得是个多么bt的db才能支撑啊？！）本来用cache的作用就是降低对某些slow query的执行次数，缓解db压力。但过期了，再去db中取这就和没有cache一样了，db会死的。</p>

<p>解决方法有这样的：</p>

<ul>
<li>有专门的job（比如crontab）来更新cache，这样request总是去cache取，不用管过不过期。好处就是简单；坏处是可能做一些没必要的重复计算，没有request你也更新了cache，而且你得确保这个job的执行时间要小于job的间隔，否则会积压很多job。</li>
<li>request取到数据发现过期，再请求一个update lock，成功拿到锁就可以更新cache，此时其他request也会请求这把锁，但就是请求不到，那就继续返回过期的数据。这是不容忍延迟的情况，如果对数据准确性要求高，那在updating的时候其他request会等，等数据更新了再返回。怎么用取决于environment。</li>
</ul>


<p>引用自：<a href="http://hype-free.blogspot.jp/2008/05/avoiding-dogpile-effect.html">http://hype-free.blogspot.jp/2008/05/avoiding-dogpile-effect.html</a>，注意blogspot。。。</p>
]]></content>
  </entry>
  
</feed>
