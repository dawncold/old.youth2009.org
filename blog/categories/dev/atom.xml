<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dev | Trade Off]]></title>
  <link href="http://www.youth2009.org/www/blog/categories/dev/atom.xml" rel="self"/>
  <link href="http://www.youth2009.org/www/"/>
  <updated>2014-03-27T22:45:57+08:00</updated>
  <id>http://www.youth2009.org/www/</id>
  <author>
    <name><![CDATA[dawncold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dive-into-tornado]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/03/27/dive-into-tornado/"/>
    <updated>2014-03-27T21:22:58+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/03/27/dive-into-tornado</id>
    <content type="html"><![CDATA[<p>早就有这样的计划，要深入了解自己在用的工具，veil算一个，tornado算一个，flask算一个……当然还有好多，总得一个个看一番，好在这些库都写得足够简单，不至于一下子看不懂，而且借助pycharm这样优秀的工具，一步步跟踪代码也给深入理解框架极大的帮助，所以，开始吧。（也好久都没更新过技术博客的内容了）</p>

<p>终于可以再让Mac发挥发挥余热了，pycharm用的社区版，估计对于学习够用了。tornado升级到了稳定的3.2版，也是目前的最新版，先慢慢研读官方的文档，再慢慢看完api。</p>

<p>keymap是个问题，平时用键盘的时候，用的是default键位，现在改用MacOS10.5+的键位，还算是熟悉，但最基本的几个（查找文件、查找符号、搜索、重构等重新熟悉了，再高级的用法估计社区版不支持）</p>

<p>在写hello，world例子的时候，处理GET我直接就下意识返回了想要的字符串，没想到运行起来是500 error，仔细一看原来官方的例子中处理GET是要调用<code>self.write('xxx')</code>，然后我就看了下self.write做了什么，self是我定义的class，但这个class继承自tornado.web.RequestHandler, 于是看tornado.web.RequestHandler的write做什么，write的参数叫chunk，并不是简单的叫str之类的东西，也就是说不限于str，有可能是些别的东西，比如注释中说如果你write了一个dict，tornado会转换成JSON，并且把Content-Type给你设置好，现在的veil也支持了这个优秀特性。还提到了list不会被转换成JSON格式，因为一个漏洞（坑），具体看<a href="http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/">这里</a>，简单讲，就是用script的src指向一个网站需要登陆后才能访问的地址，因为你如果登陆过的话，cookie信息会随之发送到这个地址，此时如果你去了一个邪恶的网站，他里面有些脚本，引用刚刚提到的你需要登陆的网址，你浏览器会把你的一些信息带上，请求这个地址，这个地址会返回一些你的个人资料，比如是用JSON的array回给你，但邪恶网站把javascript array的constructor改写了，你拿到JSON的array会被自动转成js array，这样邪恶网站会收集到你的信息，然后再发送回自己一个接受数据的接口就可以了。避免方法就是：返回JSON的时候用对象方式；这种关键信息用POST提交，script标签只会发送GET请求；现代高级浏览器都不会有问题，大可放心。转换成了byte string（就是str）放入chunk_buffer，一起写到output。</p>

<p>我们的handler很简单，实现了get方法，然后write了一个字符串，但后来呢？或许应该从另一条路看起——从url被映射到handler看起。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[return-value-in-jquery-json-datatype]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/23/return-value-in-jquery-json-datatype/"/>
    <updated>2014-01-23T18:57:21+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/23/return-value-in-jquery-json-datatype</id>
    <content type="html"><![CDATA[<p>向api server发送请求做一件事的时候，比如修改密码，server做完后没有返回值，response code是200。这在原来的时候没问题，“原来”是指ajax的dataType未指定的时候，jQuery会自己猜测用什么，但这次指定了server的response是json，所以，即便是看到200 code也未能调用OnSuccess，空返回值对于json是不合法的，于是返回一个什么东西就好，当然要先to_json再返回。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx-and-dependences]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/16/nginx-and-dependences/"/>
    <updated>2014-01-16T18:46:33+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/16/nginx-and-dependences</id>
    <content type="html"><![CDATA[<p><code>bash
wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.34.tar.gz
wget http://www.openssl.org/source/openssl-1.0.1f.tar.gz
wget http://nginx.org/download/nginx-1.5.8.tar.gz
</code></p>

<p>default install pcre and openssl</p>

<p>```
nginx configure
+gzip</p>

<p>Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + md5: using system crypto library
  + sha1: using system crypto library
  + using system zlib library
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lxml-and-dependences]]></title>
    <link href="http://www.youth2009.org/www/blog/2014/01/16/lxml-and-dependences/"/>
    <updated>2014-01-16T18:31:09+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2014/01/16/lxml-and-dependences</id>
    <content type="html"><![CDATA[<p><code>bash
sudo apt-get install libxml2-dev
sudo apt-get install libxslt1-dev
sudo apt-get install python-dev  （if Python.h: No file or dir..）
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[useful-shell-command]]></title>
    <link href="http://www.youth2009.org/www/blog/2013/12/07/useful-shell-command/"/>
    <updated>2013-12-07T22:28:53+08:00</updated>
    <id>http://www.youth2009.org/www/blog/2013/12/07/useful-shell-command</id>
    <content type="html"><![CDATA[<p>找到size为0的文件，并删除：<code>find -type f -size 0 | xargs rm</code></p>

<p>替换Linux的换行成windows的：<code>ls | xargs perl -i -pe 's/\n/\r\n/g'</code></p>

<p>批量改名哦（把<em>.md改为</em>.markdown）：</p>

<p><code>bash
for i in `ls *.md`;do mv $i `echo $i | sed 's/.md/.markdown/'`;done
</code></p>
]]></content>
  </entry>
  
</feed>
