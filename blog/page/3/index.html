
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Trade Off</title>
	<meta name="author" content="dawncold">

	
	<meta name="description" content="在wanglei的鼓动下，我开始了探寻Ruby这款被他成为做产品的语言，同时，Ruby对我来说也是上天的安排——我的生日石就是Ruby～虽然如此，其实我早就开始了Ruby的探索，曾经买过《松本行弘的程序世界》、《Ruby变成语言》这两本很好的书，无奈当时怎么看也看不进去，就暂且放弃了，相反， &hellip;">
	

	<link href="/atom.xml" rel="alternate" title="Trade Off" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
	
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-8650400-5']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


	
</head>

<body>
	<header id="header" class="inner"><nav><ul>
  <li><a href="/">Home</a></li>
  <li><a href="/about">About</li>
  <li><a href="/blog/archives">Archives</a></li>
</ul></nav>
</header>
	<div id="content" class="inner">


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2013/01/01/some-ruby-study-log/">Ruby学习记录</a></h1>
  
  








	
		<time datetime="2013-01-01T08:22:00+08:00">
			<span class="day"> 1</span><span class="month">Jan</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>在wanglei的鼓动下，我开始了探寻Ruby这款被他成为做产品的语言，同时，Ruby对我来说也是上天的安排——我的生日石就是Ruby～虽然如此，其实我早就开始了Ruby的探索，曾经买过《松本行弘的程序世界》、《Ruby变成语言》这两本很好的书，无奈当时怎么看也看不进去，就暂且放弃了，相反，更喜欢了Python。</p>

<p>最近的工作语言一直是Python，感觉很好，不过Ruby对我来说更显得优美一点，主要是喜欢他们的文档，非常全面，但不喜欢TA的快速变更，特别是ROR，当时买的书和网上的版本很难契合，我又不那么喜欢用低版本的ROR，学起来就痛苦一点，最终还是放弃了。</p>

<p>前几天看到Learn Python the Hard Way发布了3.0版，同时网站也更名为Learn Code the Hard Way，十分符合技术人士的胃口，当然用来入门还是可以的，深入的话还是得靠自己阅读更高级的书和工作实践。这个网站现在也有Ruby、C、Regex、SQL等等教程，于是在没有书的情况下，我就从这里学习Ruby了。</p>

<p>现在已经学了基本的puts和gets，能写超小的CLI了，不过还得学点loop什么的才可以，而且各种object的method也得熟悉，否则很痛苦：（</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/study/'>study</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/12/19/make-a-contribution-to-open-source-project/">给开源项目做贡献了</a></h1>
  
  








	
		<time datetime="2012-12-19T21:18:00+08:00">
			<span class="day">19</span><span class="month">Dec</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>惭愧，第一次给开源项目做贡献竟然是现在，其实早就想帮着做点啥了，无奈技术能力不足，终于发现一个机会，给progit的README文档添加MacOS用户的使用方式，可惜噩梦也是这样开始的。</p>

<p>一开始添加了usage for macos users，commit然后push，作者和我说少一个blank line，我加了再commit和push，另一个开发者和我说你不应该多次commit，需要说清楚commit的工作而不是一味用commit修改，我改好了发现remote的版本和本地不一样，因为我是在上一个版本的基础上amend后再提交的，无奈之下我merge了remote然后commit又push，这时候作者跳出来一对一教我怎么做了，有不少细节地方需要注意，比如完全的command line可以在markdown中用tab的indent，而list的indent和tab是完全不一样的。。。又给我罗列了markdown的语法。我让他写一个正确的给我看一下，他真的就给我写了一遍，但是他给希望让别人来做这部分工作而不是自己来做，并不是自己能力不足什么的，光是在我这里付出的时间就远超编辑好几个版本的README了。这点在国内开发者的身上很难发现吧？！</p>

<p>最后当然是pull request被接受了：）这次经历很难得！</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/open-source/'>open-source</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/11/25/thinking-convert-to-octopress-blog-system/">我在考虑迁移到octopress上</a></h1>
  
  








	
		<time datetime="2012-11-25T21:51:00+08:00">
			<span class="day">25</span><span class="month">Nov</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>最近的work@honovation博客一直是用octopress写的，就是直接写markdown内容即可，github负责转换并提供托管服务，而且可以自己绑定域名，比如现在的<a href="http://workathonovation.youth2009.org%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E5%BC%84%E5%BE%97%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%AE%80%E6%B4%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%80%8C%E4%B8%94%E6%9C%89%E7%A7%8D%E5%9B%9E%E5%BD%92%E6%9C%AC%E7%9C%9F%E7%9A%84%E6%84%9F%E8%A7%89%E3%80%82">http://workathonovation.youth2009.org%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E5%BC%84%E5%BE%97%EF%BC%8C%E9%9D%9E%E5%B8%B8%E7%AE%80%E6%B4%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%80%8C%E4%B8%94%E6%9C%89%E7%A7%8D%E5%9B%9E%E5%BD%92%E6%9C%AC%E7%9C%9F%E7%9A%84%E6%84%9F%E8%A7%89%E3%80%82</a></p>

<p>迟迟没有动作是因为我付了30刀个这个VPS，也就是到2月才过期，如果全部转到了octopress那么空着这个VPS干嘛？翻墙玩？呵呵，那真是无聊死了吧。。。说实在的，vps除了放个blog和自己做出来的小站外，好像就没什么用处了，但现在自己连小站都没有了，悉数关闭。。。</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/blog/'>blog</a><a class='category' href='/blog/categories/octopress/'>octopress</a><a class='category' href='/blog/categories/vps/'>vps</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/20/6-minutes-offset-in-pytz/">Pytz的6分钟时差</a></h1>
  
  








	
		<time datetime="2012-10-20T16:13:00+08:00">
			<span class="day">20</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>项目中有使用pytz这个第三方库来处理datetiem相关的东西。不过最近测试的时候发现，创建了一个时间点后，最终得到的时间点和预想的时间点有6分钟的误差，从网上搜到的资料是这样解决的：详情看<a href="http://hi.baidu.com/limodou/item/72da32384b25c7ff97f88df1">http://hi.baidu.com/limodou/item/72da32384b25c7ff97f88df1</a></p>

<p>创建datetime的时候，特别是带timezone，需要localize一下，否则在使用pytz的时候就会出现这6分钟的差异。代码中首先创建了datetime，然后localize后再replace了timezone为pytz的，最终还astimezone为pytz.utc。我们是使用utc的，你的代码也许不需要：）</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/datetime/'>datetime</a><a class='category' href='/blog/categories/pytz/'>pytz</a><a class='category' href='/blog/categories/timezone/'>timezone</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/09/nat-practical/">NAT实践</a></h1>
  
  








	
		<time datetime="2012-10-09T14:09:00+08:00">
			<span class="day"> 9</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>昨天用LXC建立了不少container，分别用来做webserver、databaseserver等等，让这些container运行着各自程序启动后如果有外部访问，就会通过iptables把请求发送到各自的地方，这里需要宿主机器做NAT。比如访问80端口，我会把请求转发到内部10.0.3.20这台container来处理，相应的response也会返回过去。这样就做到了服务隔离。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo iptables -t nat -A PREROUTING -i eth1 -p tcp --dport 80 -j DNAT --to 10.0.3.20
</span><span class='line'>sudo iptables -t nat -A POSTROUTING -o eth1 -s 10.0.3.20 -j SNAT --to 200.200.200.25
</span></code></pre></td></tr></table></div></figure>


<p>这样就把进入的请求都发到了10.0.3.20这台container上去处理。</p>

<p><img src="http://pic.yupoo.com/dawncold0/CkkIbzDr/medish.jpg" alt="nat" /></p>

<p>只默认开了一个nginx，就这样的效果。</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/iptables/'>iptables</a><a class='category' href='/blog/categories/lxc/'>lxc</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/08/lxc-practical/">LXC实践</a></h1>
  
  








	
		<time datetime="2012-10-08T20:46:00+08:00">
			<span class="day"> 8</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>这里的LXC是基于Ubuntu12.04的，在其他系统下可能不太一样。</p>

<p>0.安装lxc</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install lxc
</span></code></pre></td></tr></table></div></figure>


<p>1.修改lxc的mirror，不修改的话下载一个ubuntu景象会非常慢！！！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo emacs /etc/default/lxc
</span><span class='line'>第三行的mirror注释去掉，并修改为cn.archive.ubuntu.com，这样就非常快了
</span></code></pre></td></tr></table></div></figure>


<p>2.创建lxc容器，t表示模板中的名字，n表示这个容器的名字（可自定义）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo lxc-create -t ubuntu -n ubuntu_container
</span></code></pre></td></tr></table></div></figure>


<p>3.启动容器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo lxc-start -n ubuntu_container
</span></code></pre></td></tr></table></div></figure>


<p>启动后就会出现登录ubuntu的界面，刚刚创建好容器后会给出一个提示，帐号密码都是ubuntu，登录进去就可以使用了。</p>

<p>猜想lxc的用法可能是对于部署的某个进程使用lxc隔离，这并不能做vps用，lxc只是轻量虚拟化，针对进程来的，所以还是单机在使用，如果做vps就得用vmware、xen、openvz这样的东西了。</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/lxc/'>lxc</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/08/lvm-and-raid1/">LVM+RAID实践</a></h1>
  
  








	
		<time datetime="2012-10-08T14:09:00+08:00">
			<span class="day"> 8</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>两块256Gb SSD，做RAID1，用LVM管理，方便日后动态扩容等。</p>

<p>0.分区，因为是SSD，需要注意4K对齐问题，否则对SSD的寿命和性能有影响：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>fdisk /dev/sda
</span><span class='line'>fdisk /dev/sdb
</span></code></pre></td></tr></table></div></figure>


<p>1.创建PV</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo pvcreate /dev/sd<span class="o">{</span>a1,b1<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.创建VG</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vgcreate -s 16M vg0 /dev/sd<span class="o">{</span>a1,b1<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>3.创建LV</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo lvcreate -n lv0 vg0 -m 1 -lxxxx --corelog
</span></code></pre></td></tr></table></div></figure>


  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/lvm/'>lvm</a><a class='category' href='/blog/categories/raid1/'>raid1</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/04/print-words-count/">统计词频方法</a></h1>
  
  








	
		<time datetime="2012-10-04T18:32:00+08:00">
			<span class="day"> 4</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>记得上次参加美味书签电面的时候被问到如何统计一个语料库中的词频，当时有点傻，刚刚在复习Python的dict也遇到了这样的问题，一下子认识到，原来可以做得这么简单。虽然不知道有没有更爽的办法，但我觉得我这种方法也算是能用了，能够保证一定效率的情况下，可理解性也很强。</p>

<p>读取一行行的word，存入dict，word作为key，value就是出现次数了，这样都是linear的事件复杂度，如果在字典就把value加1，要是不在就把value设为1即可。dict的查找复杂度很低，是hash查找。</p>

<p>唉，会不会就是这样我才被拒掉了呢？！</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/dict/'>dict</a><a class='category' href='/blog/categories/meiwei-dot-fm/'>meiwei.fm</a><a class='category' href='/blog/categories/python/'>python</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/04/dict-formatting-in-python/">Python中dict格式化</a></h1>
  
  








	
		<time datetime="2012-10-04T17:54:00+08:00">
			<span class="day"> 4</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>最近在工作中遇到过写SQL的问题，参数是直接传递进去的，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">db</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s">&#39;SELECT * FROM xxx WHERE id = </span><span class="si">%(id)s</span><span class="s">&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">get_id</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<p>今天细看Google提供的Python课程发现一个叫DictFormatting的部分，里面就有类似这样的语法，现在才明白。以前用过Python的格式化输出，其实这个dict的格式化和字符串的类似，就是在字符串格式化的基础之上加入了dict的key，%s是表示这里有字符串，而%(xxx)s是表示字符串，而且是以xxx为key的字符串，这个value就是从字典中给出。一半会在这样一个字符串后加“% dictname”表示值从dictname这个字典中给出，这不就是和字符串格式化一样么。</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/dict/'>dict</a><a class='category' href='/blog/categories/python/'>python</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


	<article class="post"><header>
  
  <h1 class="title"><a href="/blog/2012/10/04/sort-method-in-python/">Python中的sort方法</a></h1>
  
  








	
		<time datetime="2012-10-04T14:58:00+08:00">
			<span class="day"> 4</span><span class="month">Oct</span>
		</time>
	

</header>
<div class="entry-content">
  
    <p>打算从今天开始自习再学学Python的基础，选了Google提供的Python课程，学到list部分，有个练习题目要求针对一组tuples排序，根据tuples的最后一个元素排序，有个hint，可以用key=function这种方法，于是搜索了一番，在Python的wiki中找到这个key方法的描述：</p>

<p>从Python2.4以后list.sort()和sorted()方法都提供了一个key可选参数，传入一个function用来决定排序需要的key。这个key就是所排序元素的权值，最终就是根据权值来排序了。你也可以自己写一个方法，就是那种用def来定义的方法，不过要求接受一个参数，返回一个值，接受的参数就是这个集合（list、dict、tuple）中的某个元素。我是这样写的，it works：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">sort_last</span><span class="p">(</span><span class="n">tuples</span><span class="p">):</span>
</span><span class='line'> <span class="c"># +++your code here+++</span>
</span><span class='line'> <span class="n">tuples</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'> <span class="k">return</span> <span class="n">tuples</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据tuple中最后一个排序。</p>

  
  
  <footer class="meta">
    



	<div class="tags"><a class='category' href='/blog/categories/python/'>python</a><a class='category' href='/blog/categories/sort/'>sort</a><a class='category' href='/blog/categories/ji-zhu/'>技术</a></div>

    
  </footer>
  
</div>
</article>


<nav id="pagenavi">
	<a href="/blog/page/2/" class="prev alignleft">Prev</a>
	<a href="/blog/page/4/" class="next alignright">Next</a>
 <div class="clearfix"></div>
</nav>
</div>
	<footer id="footer" class="inner"><div class="social alignright">
	
	
	
	
	
	<a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>&copy; 2013 dawncold</p>
<div class="clearfix"></div></footer>
	<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
	(function($){
		$('.entry-content').each(function(i){
			var _i = i;
			$(this).find('img').each(function(){
				var alt = $(this).attr('alt');

				if (alt == '' || typeof alt == 'undefined'){
					$(this).wrap('<a href="'+$(this).attr('src')+'" class="fancybox" rel="gallery'+_i+'" />');
				} else {
					$(this).after('<span class="caption">'+alt+'</span>').wrap('<a href="'+$(this).attr('src')+'" class="fancybox" title="'+alt+'" rel="gallery'+_i+'" />');
				}
			});
		});
		$('.fancybox').fancybox();
	})(jQuery);
</script>
<div id="phasebeam">
	<canvas></canvas>
	<canvas></canvas>
	<canvas></canvas>
</div>
<script src="/javascripts/phasebeam.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'dawncoldtechblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



</body>
</html>